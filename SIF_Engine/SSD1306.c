
#include "SebEngine.h"
#include "SSD1306.h"

void TestFrame(SSD1306_128x64x1_t* S, u8 pattern);

SSD1306_128x64x1_t SSD;

u32 sq_I2C_MIO_StartJob(u32 u);
u32 sq_I2C_MIO_StopJob(u32 u);
u32 sq_I2C_MIO_MoveJob(u32 u);

static I2C_MasterIO_t gMIO;
static IO_Pin_t MIO_SDA, MIO_SCL;
static Timer_t Timer6;
// create the instructions

const OneJob_t StartWriteSSD1306 =        { sq_I2C_MIO_StartJob, (u32)&gMIO, 0x78 };
OneJob_t WriteSSD1306Command =      { sq_I2C_MIO_MoveJob,  (u32)&gMIO, (u32)SSD.BytesTX, 2, 0 }; // no more coming
OneJob_t StartReadSSD1306 =  { sq_I2C_MIO_StartJob, (u32)&gMIO, 0x79 };
const OneJob_t ReadSSD1306Byte =       { sq_I2C_MIO_MoveJob,  (u32)&gMIO, (u32)SSD.BytesRX, 1, 0 };

static u32 List[100]; // list of pointers
static StuffsArtery_t mySequence;

void SSD1306_SendCommand(SSD1306_128x64x1_t* S, u32 Cmd) {

// it looks a bit indirect, however it's going to become better later with this structure for background processing (HW I2C)  
  S->BytesTX[0] = 0;// one byte to send
  S->BytesTX[1] = 0x80 | Cmd;
  AddToSA(S->I2C->SA, (u32) &StartWriteSSD1306);
  AddToSA(S->I2C->SA, (u32) &WriteSSD1306Command);
  StartJobToDoInForeground((u32)S->I2C->SA);
  while(S->I2C->SA->FlagEmptied==0);
  NOPs(1);     
}

u8 FrameID=0;

void SSD1306_Test(void) {

//  u32 u = (u32)&gMIO;
  MCUInitClocks();
//  Timer6.Clocks = &MCU_Clocks;
//  NewTimer(&Timer6, TIM6);
//  SetTimerTimings_us(&Timer6, 4);
//  ConfigureTimer(&Timer6);
//  gMIO.Timer = &Timer6;
//  gMIO.Cn = 0; // use Countdown[0]
// 400kHz means 2.5us cycle perid, or 1.25us clock toggle frequency
  gMIO.Clocks = &MCU_Clocks; // Attach the global clocktree info to the cell. (the clock tree is unique)
  NewI2C_MasterIO_SDA_SCL(&gMIO, NewIO_Pin(&MIO_SDA,PH7), NewIO_Pin(&MIO_SCL,PH8) );
  SetI2C_MasterIO_Timings(&gMIO, 100000, 400000 );
  SetI2C_MasterIO_Format( &gMIO );

  ConfigureI2C_MasterIO(&gMIO);
  EnableI2C_MasterIO(&gMIO);
  // all zero: no action
  NVIC_TimersEnable(ENABLE);

  //===============
  StuffsArtery_t* P = &mySequence; // program
  gMIO.SA = NewSA(P, (u32)&List[0], countof(List));
  
  SSD.I2C = &gMIO;

  SSD1306(&SSD);
  
  
  while(1) {

    TestFrame(&SSD, FrameID);   
    SSD1306sendFramebuffer(&SSD);

    SSD1306invert(&SSD, 1);
    Wait_ms(500);
    SSD1306invert(&SSD, 0);
    Wait_ms(500);
  }
};

#define CMD1(a) 0x80,(a)
#define CMD2(a,b) 0x80,(a),0x80,(b)

const u8 SSD_Init_Stream[] = {
CMD1(SSD1306_DISPLAYOFF),
CMD2(SSD1306_SETDISPLAYCLOCKDIV,0x80),
CMD2(SSD1306_SETMULTIPLEX,0x3F),
CMD2(SSD1306_SETDISPLAYOFFSET,0x00),
CMD1(SSD1306_SETSTARTLINE | 0x00),
// we use internal charge pump
CMD2(SSD1306_CHARGEPUMP,0x14),
// Horizontal memory mode
CMD2(SSD1306_MEMORYMODE,0x02),// page mode for cheapo copycats 0x00),
CMD1(SSD1306_SEGREMAP|1),
CMD1(SSD1306_COMSCANDEC),
CMD2(SSD1306_SETCOMPINS,0x12),
// Max contrast
CMD2(SSD1306_SETCONTRAST,0xCF),
CMD2(SSD1306_SETPRECHARGE,0xF1),
CMD2(SSD1306_SETVCOMDETECT,0x40),
CMD1(SSD1306_DISPLAYALLON_RESUME),
// Non inverted display
CMD1(SSD1306_NORMALDISPLAY),
// Turn Display On
CMD1(SSD1306_DISPLAYON) 
};

OneJob_t WriteSSD1306InitSequence =      { sq_I2C_MIO_MoveJob,  (u32)&gMIO, (u32)SSD_Init_Stream, countof(SSD_Init_Stream), 0 }; // no more coming

void SSD1306(SSD1306_128x64x1_t* S) {
  

  AddToSA(S->I2C->SA, (u32) &StartWriteSSD1306);
  AddToSA(S->I2C->SA, (u32) &WriteSSD1306InitSequence);
  StartJobToDoInForeground((u32)S->I2C->SA);
  while(S->I2C->SA->FlagEmptied==0);  
  NOPs(1);
  return;
  // Turn display off
  SSD1306_SendCommand(S, SSD1306_DISPLAYOFF);
  Wait_ms(100);

  SSD1306_SendCommand(S, SSD1306_SETDISPLAYCLOCKDIV);
  SSD1306_SendCommand(S, 0x80);

  SSD1306_SendCommand(S, SSD1306_SETMULTIPLEX);
  SSD1306_SendCommand(S, 0x3F);
  
  SSD1306_SendCommand(S, SSD1306_SETDISPLAYOFFSET);
  SSD1306_SendCommand(S, 0x00);
  
  SSD1306_SendCommand(S, SSD1306_SETSTARTLINE | 0x00);
  
  // We use internal charge pump
  SSD1306_SendCommand(S, SSD1306_CHARGEPUMP);
  SSD1306_SendCommand(S, 0x14);
  
  // Horizontal memory mode
  SSD1306_SendCommand(S, SSD1306_MEMORYMODE);
  SSD1306_SendCommand(S, 0x00);
  
  SSD1306_SendCommand(S, SSD1306_SEGREMAP | 0x1);

  SSD1306_SendCommand(S, SSD1306_COMSCANDEC);

  SSD1306_SendCommand(S, SSD1306_SETCOMPINS);
  SSD1306_SendCommand(S, 0x12);

  // Max contrast
  SSD1306_SendCommand(S, SSD1306_SETCONTRAST);
  SSD1306_SendCommand(S, 0xCF);

  SSD1306_SendCommand(S, SSD1306_SETPRECHARGE);
  SSD1306_SendCommand(S, 0xF1);

  SSD1306_SendCommand(S, SSD1306_SETVCOMDETECT);
  SSD1306_SendCommand(S, 0x40);

  SSD1306_SendCommand(S, SSD1306_DISPLAYALLON_RESUME);

  // Non-inverted display
  SSD1306_SendCommand(S, SSD1306_NORMALDISPLAY);

  // Turn display back on
  SSD1306_SendCommand(S, SSD1306_DISPLAYON);
  Wait_ms(100);
}

void SSD1306invert(SSD1306_128x64x1_t* S, uint8_t inverted) {
  
    if (inverted) {
        SSD1306_SendCommand(S, SSD1306_INVERTDISPLAY);
    } else {
        SSD1306_SendCommand(S, SSD1306_NORMALDISPLAY);
    }
}


void TestFrame(SSD1306_128x64x1_t* S, u8 pattern) {
  
  for(u16 n=0; n<countof(S->Frame); n++) {
    S->Frame[n] = 0x5A;//(n & 0xFF)^pattern;
  }
  
}

   
// Set page address 0~15
void Set_Page_Address(unsigned char add)
{
  /*
	Start();
	SentByte(Write_Address);
	SentByte(0x80);
    add=0xb0|add;
	SentByte(add);
    _nop_();
	*/
  SSD1306_SendCommand(&SSD, 0xB0|add);
}

void Set_Column_Address(unsigned char add)
{/*
	Start();
	SentByte(Write_Address);
	SentByte(0x80);
	SentByte((0x10|(add>>4)));
	SentByte(0x80);
	SentByte((0x0f&add));
 	Stop();
	*/
  SSD1306_SendCommand(&SSD, 0x10 | (add>>4));
  SSD1306_SendCommand(&SSD, 0x0F & add);
}



const u8 FrameWrite = 0x40;

const OneJob_t WriteSSD1306FrameCmd =   { sq_I2C_MIO_MoveJob,  (u32)&gMIO, (u32)&FrameWrite, 1, 1 }; // no more coming
OneJob_t WriteSSD1306Frame =      { sq_I2C_MIO_MoveJob,  (u32)&gMIO, (u32)&SSD.Frame[0], 128, 0 }; // no more coming

void SSD1306sendFramebuffer(SSD1306_128x64x1_t* S) {

//    SSD1306_SendCommand(S, 0x20);
//    SSD1306_SendCommand(S, 0x02); // page addressing mode (works with various copycats of the 1306...
    
//    SSD1306_SendCommand(S, SSD1306_COLUMNADDR);
//    SSD1306_SendCommand(S, 0x00);
//    SSD1306_SendCommand(S, 0x7F);

//    SSD1306_SendCommand(S, SSD1306_PAGEADDR);
//    SSD1306_SendCommand(S, 0x00);
//    SSD1306_SendCommand(S, 0x07);

  
  for(u8 i=0;i<8;i++) {
  
    Set_Page_Address(i);
    Set_Column_Address(0);
    WriteSSD1306Frame.ctJobs[1] = (u32) &SSD.Frame[i*128];
    AddToSA(S->I2C->SA, (u32) &StartWriteSSD1306);  
    AddToSA(S->I2C->SA, (u32) &WriteSSD1306FrameCmd);
    AddToSA(S->I2C->SA, (u32) &WriteSSD1306Frame);
    StartJobToDoInForeground((u32)S->I2C->SA);
    while(S->I2C->SA->FlagEmptied==0);
    NOPs(1);     
  };
// finished!

}


//=============== Drawing related
#if 0
const u8 OledFont[][8] =
{
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
  {0x00,0x00,0x5F,0x00,0x00,0x00,0x00,0x00},
  {0x00,0x00,0x07,0x00,0x07,0x00,0x00,0x00},
  {0x00,0x14,0x7F,0x14,0x7F,0x14,0x00,0x00},
  {0x00,0x24,0x2A,0x7F,0x2A,0x12,0x00,0x00},
  {0x00,0x23,0x13,0x08,0x64,0x62,0x00,0x00},
  {0x00,0x36,0x49,0x55,0x22,0x50,0x00,0x00},
  {0x00,0x00,0x05,0x03,0x00,0x00,0x00,0x00},
  {0x00,0x1C,0x22,0x41,0x00,0x00,0x00,0x00},
  {0x00,0x41,0x22,0x1C,0x00,0x00,0x00,0x00},
  {0x00,0x08,0x2A,0x1C,0x2A,0x08,0x00,0x00},
  {0x00,0x08,0x08,0x3E,0x08,0x08,0x00,0x00},
  {0x00,0xA0,0x60,0x00,0x00,0x00,0x00,0x00},
  {0x00,0x08,0x08,0x08,0x08,0x08,0x00,0x00},
  {0x00,0x60,0x60,0x00,0x00,0x00,0x00,0x00},
  {0x00,0x20,0x10,0x08,0x04,0x02,0x00,0x00},
  {0x00,0x3E,0x51,0x49,0x45,0x3E,0x00,0x00},
  {0x00,0x00,0x42,0x7F,0x40,0x00,0x00,0x00},
  {0x00,0x62,0x51,0x49,0x49,0x46,0x00,0x00},
  {0x00,0x22,0x41,0x49,0x49,0x36,0x00,0x00},
  {0x00,0x18,0x14,0x12,0x7F,0x10,0x00,0x00},
  {0x00,0x27,0x45,0x45,0x45,0x39,0x00,0x00},
  {0x00,0x3C,0x4A,0x49,0x49,0x30,0x00,0x00},
  {0x00,0x01,0x71,0x09,0x05,0x03,0x00,0x00},
  {0x00,0x36,0x49,0x49,0x49,0x36,0x00,0x00},
  {0x00,0x06,0x49,0x49,0x29,0x1E,0x00,0x00},
  {0x00,0x00,0x36,0x36,0x00,0x00,0x00,0x00},
  {0x00,0x00,0xAC,0x6C,0x00,0x00,0x00,0x00},
  {0x00,0x08,0x14,0x22,0x41,0x00,0x00,0x00},
  {0x00,0x14,0x14,0x14,0x14,0x14,0x00,0x00},
  {0x00,0x41,0x22,0x14,0x08,0x00,0x00,0x00},
  {0x00,0x02,0x01,0x51,0x09,0x06,0x00,0x00},
  {0x00,0x32,0x49,0x79,0x41,0x3E,0x00,0x00},
  {0x00,0x7E,0x09,0x09,0x09,0x7E,0x00,0x00},
  {0x00,0x7F,0x49,0x49,0x49,0x36,0x00,0x00},
  {0x00,0x3E,0x41,0x41,0x41,0x22,0x00,0x00},
  {0x00,0x7F,0x41,0x41,0x22,0x1C,0x00,0x00},
  {0x00,0x7F,0x49,0x49,0x49,0x41,0x00,0x00},
  {0x00,0x7F,0x09,0x09,0x09,0x01,0x00,0x00},
  {0x00,0x3E,0x41,0x41,0x51,0x72,0x00,0x00},
  {0x00,0x7F,0x08,0x08,0x08,0x7F,0x00,0x00},
  {0x00,0x41,0x7F,0x41,0x00,0x00,0x00,0x00},
  {0x00,0x20,0x40,0x41,0x3F,0x01,0x00,0x00},
  {0x00,0x7F,0x08,0x14,0x22,0x41,0x00,0x00},
  {0x00,0x7F,0x40,0x40,0x40,0x40,0x00,0x00},
  {0x00,0x7F,0x02,0x0C,0x02,0x7F,0x00,0x00},
  {0x00,0x7F,0x04,0x08,0x10,0x7F,0x00,0x00},
  {0x00,0x3E,0x41,0x41,0x41,0x3E,0x00,0x00},
  {0x00,0x7F,0x09,0x09,0x09,0x06,0x00,0x00},
  {0x00,0x3E,0x41,0x51,0x21,0x5E,0x00,0x00},
  {0x00,0x7F,0x09,0x19,0x29,0x46,0x00,0x00},
  {0x00,0x26,0x49,0x49,0x49,0x32,0x00,0x00},
  {0x00,0x01,0x01,0x7F,0x01,0x01,0x00,0x00},
  {0x00,0x3F,0x40,0x40,0x40,0x3F,0x00,0x00},
  {0x00,0x1F,0x20,0x40,0x20,0x1F,0x00,0x00},
  {0x00,0x3F,0x40,0x38,0x40,0x3F,0x00,0x00},
  {0x00,0x63,0x14,0x08,0x14,0x63,0x00,0x00},
  {0x00,0x03,0x04,0x78,0x04,0x03,0x00,0x00},
  {0x00,0x61,0x51,0x49,0x45,0x43,0x00,0x00},
  {0x00,0x7F,0x41,0x41,0x00,0x00,0x00,0x00},
  {0x00,0x02,0x04,0x08,0x10,0x20,0x00,0x00},
  {0x00,0x41,0x41,0x7F,0x00,0x00,0x00,0x00},
  {0x00,0x04,0x02,0x01,0x02,0x04,0x00,0x00},
  {0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00},
  {0x00,0x01,0x02,0x04,0x00,0x00,0x00,0x00},
  {0x00,0x20,0x54,0x54,0x54,0x78,0x00,0x00},
  {0x00,0x7F,0x48,0x44,0x44,0x38,0x00,0x00},
  {0x00,0x38,0x44,0x44,0x28,0x00,0x00,0x00},
  {0x00,0x38,0x44,0x44,0x48,0x7F,0x00,0x00},
  {0x00,0x38,0x54,0x54,0x54,0x18,0x00,0x00},
  {0x00,0x08,0x7E,0x09,0x02,0x00,0x00,0x00},
  {0x00,0x18,0xA4,0xA4,0xA4,0x7C,0x00,0x00},
  {0x00,0x7F,0x08,0x04,0x04,0x78,0x00,0x00},
  {0x00,0x00,0x7D,0x00,0x00,0x00,0x00,0x00},
  {0x00,0x80,0x84,0x7D,0x00,0x00,0x00,0x00},
  {0x00,0x7F,0x10,0x28,0x44,0x00,0x00,0x00},
  {0x00,0x41,0x7F,0x40,0x00,0x00,0x00,0x00},
  {0x00,0x7C,0x04,0x18,0x04,0x78,0x00,0x00},
  {0x00,0x7C,0x08,0x04,0x7C,0x00,0x00,0x00},
  {0x00,0x38,0x44,0x44,0x38,0x00,0x00,0x00},
  {0x00,0xFC,0x24,0x24,0x18,0x00,0x00,0x00},
  {0x00,0x18,0x24,0x24,0xFC,0x00,0x00,0x00},
  {0x00,0x00,0x7C,0x08,0x04,0x00,0x00,0x00},
  {0x00,0x48,0x54,0x54,0x24,0x00,0x00,0x00},
  {0x00,0x04,0x7F,0x44,0x00,0x00,0x00,0x00},
  {0x00,0x3C,0x40,0x40,0x7C,0x00,0x00,0x00},
  {0x00,0x1C,0x20,0x40,0x20,0x1C,0x00,0x00},
  {0x00,0x3C,0x40,0x30,0x40,0x3C,0x00,0x00},
  {0x00,0x44,0x28,0x10,0x28,0x44,0x00,0x00},
  {0x00,0x1C,0xA0,0xA0,0x7C,0x00,0x00,0x00},
  {0x00,0x44,0x64,0x54,0x4C,0x44,0x00,0x00},
  {0x00,0x08,0x36,0x41,0x00,0x00,0x00,0x00},
  {0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x00},
  {0x00,0x41,0x36,0x08,0x00,0x00,0x00,0x00},
  {0x00,0x02,0x01,0x01,0x02,0x01,0x00,0x00},
  {0x00,0x02,0x05,0x05,0x02,0x00,0x00,0x00}
};


void oledCommand( uint8_t ch )
{
    uint8_t bytes[2];
    bytes[0] = SSD1308_Command_Mode;
    bytes[1] = ch;
    i2c1Xfer( SSD1308_Address, bytes, 2, NULL, 0 );
}


void oledDisplayOffset( uint8_t offset )
{
    uint8_t bytes[3];
    bytes[0] = SSD1308_Command_Mode;
    bytes[1] = 0xD3;
    bytes[2] = offset;
    i2c1Xfer( SSD1308_Address, bytes, 3, NULL, 0 );
}


void oledData( uint8_t data )
{
    uint8_t bytes[2];
    bytes[0] = SSD1308_Data_Mode;
    bytes[1] = data;
    i2c1Xfer( SSD1308_Address, bytes, 2, NULL, 0 );
}


void oledGotoYX(unsigned char Row, unsigned char Column)
{
    oledCommand( 0xB0 + Row);
    oledCommand( 0x00 + (8*Column & 0x0F) );
    oledCommand( 0x10 + ((8*Column>>4)&0x0F) );
}


void oledPutChar( char ch )
{
    if ( ( ch < 32 ) || ( ch > 127 ) )
        ch = ' ';

    const uint8_t *base = &OledFont[ch - 32][0];

    uint8_t bytes[9];
    bytes[0] = SSD1308_Data_Mode;
    memmove( bytes + 1, base, 8 );
    i2c1Xfer( SSD1308_Address, bytes, 9, NULL, 0 );
}


void oledPrint( char *s )
{
    while (*s) oledPutChar( *s++);
}


void oledClear()
{
    for ( uint16_t row = 0; row < 8; row++ ) {
        for ( uint16_t col = 0; col < 16; col++ ) {
            oledGotoYX( row, col );
            oledPutChar( ' ' );
        }
    }
}


void oledInit()
{
    oledCommand( SSD1308_Display_Off_Cmd );
    __delay_ms( 100 );
    oledCommand( SSD1308_Display_On_Cmd );
    __delay_ms( 100 );
    oledCommand( SSD1308_Normal_Display_Cmd );
    oledCommand( SSD1308_Dectivate_Scroll_Cmd );
}

void test(void) {

  oledInit();
  oledClear();

  oledGotoYX( 0, 0 );
  oledPrint( "OLED SSD1308" );

  uint16_t count = 0;
  while ( 1 ) {
    char s[20];
    itoa( s, count, 10 );
    oledGotoYX( 2, 0 );
    oledPrint( s );
    oledPrint( "     " );
    __delay_ms( 100 );
    count++;
  };

}
#endif